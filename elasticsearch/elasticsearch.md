[toc]

## 简介

**倒排索引**

在谷歌等搜索引擎中，一种常见的搜索方式是根据关键词返回相关的文档，即`word => doc`。`doc => word`这种查询的索引被称为正向索引（forward index），那么`word => doc`这种查询的索引就叫做倒排索引（反向索引，inverted index）了。

```
DICTIONARY     =====>     DOC
ada						 [1,2,3]
bob                      [2]
```

**ES 的 Dictionary 优化**

除了保存最基本的`word => doc`的映射，为了加速`word`这一层的查询，Lucene 在`Dictionary`的左边加了一层“字典树”，通过字典树可以定位单词的块，再在块中用二分查找得到单词的位置。

> 引入字典树是为了在不把字典全部缓存到内存的前提下，也能加速查询单词
>
> 除了字典树，ES 还引入了FST（有限状态转换器，Finite State Transducers）来减少内存占用

**ES 的 Posting list 优化**

ES 最右边的一层 DOC，虽然只是一些文档 ID 数组，但是 ES 也在这里做了优化，优化的目标有：

* 节省磁盘空间
* 快速求交集、并集

节省磁盘空间：

* 存储 DOC ID 的增量 + 分块：从存储原始的文档列表，变成存储文档 ID 的增量，比如：

  ```
  [73, 300, 302, 332, 343, 372] =>
  [73, 227, 2, 30, 11, 29]
  ```

  因为 Lucene 是用 segment 存储数据的（最多存 65536 个 ID），每个 segment 被分成块，每个块最多存 256 个 ID，这样用增量存储后，可以用更少位数存数据

* 按需分配空间：在上面分块的基础上，检查每个块的最大值需要分配多少位，达到按需分配。比如`227`就需要8 位，`30`就需要 5 位

快速求交并集：

使用 bitmap，用位运算

**为什么 ES 不使用 B+ 树存储？**

b+树主要设计目的是减少搜索时访问磁盘的次数，而Lucene等搜索引擎设计的时候，追求的目标是倒排压缩率&倒排解压速度&倒排Bool运算速度。取倒排到内存运算的时候，是连续读取，时间开销和倒排的大小有关系，所以并不适合用b+数。
同理Mysql等数据库使用索引的目的是快速定位某一行数据，若使用倒排这种线性化的数据结构存储数据，其查找的时候访问磁盘的次数会远大于使用b+的数据库。
