

# My reflection

现在我学完了 CS61A 的大部分内容，特此写一篇文章记录一下。很长一段时间，我都没有在读完一本书、看完一部电影之后写感想了。很难相信懒狗如我，竟然会在学完网课之后写个感想。



[toc]

## 为什么学CS61A？

为什么要要学 CS61A？其实我一开始是拒绝的。在萌生学习网课这个想法的时候，我的目标只有 CS 的四大专业课，后面做了 CMU 的 CS144 Computer Networking 的 Lab 之后，我被高质量的 Lab 以及我的菜鸡程度震撼到了（后者我很早就认识到了）。意识到问题之后，我开始找一些更基础的课程。作为 UCB 的 CS 入门课，CS61A 既有编程语言的部分，又深入到了程序构造和运行的原理，而且后面还有神奇的函数式编程 Scheme。感谢这个时代的开源精神以及 UCB，让我也能接触到一流的 CS 科班教育。

说到 FP，虽然不太相关，我想起了之前逛 Arxiv 时误入 PL 分区的感觉：第一眼看到的完全是一堆鬼画符。但是我接触了 FP 之后，确实对递归和函数式调用有了一点理解和兴趣。读本科那会逛知乎，看到有大佬说“CS 人总会在某个时候对 FP 或者 PL 感兴趣”，现在我也被言中了，果然人就是会对这种屠龙技感兴趣啊。后面我有时间也许会看看 Haskell 和 Ocaml 了。



## CS61A 主要内容

这门课是 SICP in Python，主要讲了用函数构造计算机程序（函数设计、高阶函数、递归函数），用数据构造计算机程序（数据抽象、OOP），解释计算机程序（函数式编程、异常、REPL解释器）



## 我学到的

我之前也零零散散地学过一些数据结构、刷过一些 Leetcode，但是知识点较为零散，在写递归的题的时候还是会想很久，这门课相当于把这些内容串起来了，函数式编程确实能让人更深刻地理解递归。

除了课堂讲述的内容，我印象较深的有以下这些：

* 解决问题的一般思路

  > 1. 从分析问题到定义数据：阅读问题，寻找必须要被抽象化（表示）的信息，并思考用何种数据结构表示。寻找实际例子。
  > 2. 函数签名、目的描述、以及 docstring ：思考解决问题的函数的输入与输出，准确描述这个函数在计算什么并撰写 docstring 。
  > 3. 例子推演：通过例子推演计算的步骤，编写核心的步骤，设计函数的骨架。
  > 4. 函数定义：编写剩下的函数使其能够支撑核心步骤，通过例子意识变量与表达式的实际意义。
  > 5. 测试：使用例子推演函数、并使用 doctest 测试、修改错误、把程序修改得更为易读。

* 代码如何被解释和执行

  > 调用一个函数时 operator 和 operands 的计算顺序、程序执行的 frame 和 environment、可变与不可变数据、多重赋值、nonlocal 赋值、异常处理等



## 一些感想

我在学这门网课的途中，主要看的材料只用了文字版的教材和 Lab，并没有看 Lecture 的视频，即使是这样，我其实中间也是很想放弃的，毕竟没有学业的压力，而且学的是基础课，很容易半途而废。但是 Lab 中详细的文档、自动化测试工具、文字版教材的 py tutor（显示 frame 的那个）还是让我坚持了下来，UCB 真有你的啊！

